{"version":3,"file":"330.prod.js","mappings":"iHAGA,KAAgB,GAAK,QAAQ,GAAK,SAAS,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,cAAc,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,UAAU,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,aAAa,GAAK,UAAU,GAAK,WAAW,GAAK,UAAU,GAAK,cAAc,GAAK,aAAa,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,UAAU,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,QAAQ,GAAK,YAAY,GAAK,YAAY,GAAK,cAAc,GAAK,aAAa,GAAK,WAAW,GAAK,WAAW,GAAK,UAAU,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,cAAc,GAAK,WAAW,GAAK,WAAW,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,UAAU,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,UAAU,GAAK,QAAQ,GAAK,UAAU,GAAK,SAAS,GAAK,YAAY,GAAK,WAAW,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,YAAY,GAAK,WAAW,GAAK,SAAS,GAAK,UAAU,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,UAAU,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,aAAa,GAAK,UAAU,GAAK,aAAa,GAAK,aAAa,GAAK,UAAU,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,UAAU,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,WAAW,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,UAAU,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,WAAW,GAAK,aAAa,GAAK,WAAW,GAAK,WAAW,GAAK,UAAU,GAAK,YAAY,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,SAAS,GAAK,WAAW,GAAK,SAAS,GAAK,aAAa,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,aAAa,GAAK,UAAU,GAAK,UAAU,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,SAAS,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,UAAU,GAAK,YAAY,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,YAAY,GAAK,YAAY,GAAK,UAAU,GAAK,UAAU,GAAK,YAAY,GAAK,YAAY,GAAK,WAAW,GAAK,QAAQ,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,WAAW,GAAK,UAAU,GAAK,YAAY,GAAK,UAAU,GAAK,WAAW,GAAK,aAAa,GAAK,YAAY,GAAK,WAAW,GAAK,OAAO,GAAK,aAAa,GAAK,WAAW,GAAK,WAAW,GAAK,YAAY,GAAK,YAAY,GAAK,OAAO,GAAK,WAAW,GAAK,WAAW,GAAK,WAAW,GAAK,UAAU,GAAK,aAAa,GAAK,aAAa,GAAK,SAAS,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,YAAY,GAAK,aAAa,GAAK,WAAW,GAAK,YAAY,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,aAAa,GAAK,YAAY,GAAK,UAAU,GAAK,SAAS,GAAK,UAA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","sources":["webpack://tinode-webapp/./node_modules/libphonenumber-js/examples.mobile.json.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeState.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouTypeParser.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/AsYouType.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/mobile/exports/AsYouType.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/es6/getExampleNumber.js","webpack://tinode-webapp/./node_modules/libphonenumber-js/mobile/exports/getExampleNumber.js"],"sourcesContent":["// This file is a workaround for a bug in web browsers' \"native\"\n// ES6 importing system which is uncapable of importing \"*.json\" files.\n// https://github.com/catamphetamine/libphonenumber-js/issues/239\nexport default {\"AC\":\"40123\",\"AD\":\"312345\",\"AE\":\"501234567\",\"AF\":\"701234567\",\"AG\":\"2684641234\",\"AI\":\"2642351234\",\"AL\":\"672123456\",\"AM\":\"77123456\",\"AO\":\"923123456\",\"AR\":\"91123456789\",\"AS\":\"6847331234\",\"AT\":\"664123456\",\"AU\":\"412345678\",\"AW\":\"5601234\",\"AX\":\"412345678\",\"AZ\":\"401234567\",\"BA\":\"61123456\",\"BB\":\"2462501234\",\"BD\":\"1812345678\",\"BE\":\"470123456\",\"BF\":\"70123456\",\"BG\":\"43012345\",\"BH\":\"36001234\",\"BI\":\"79561234\",\"BJ\":\"0195123456\",\"BL\":\"690001234\",\"BM\":\"4413701234\",\"BN\":\"7123456\",\"BO\":\"71234567\",\"BQ\":\"3181234\",\"BR\":\"11961234567\",\"BS\":\"2423591234\",\"BT\":\"17123456\",\"BW\":\"71123456\",\"BY\":\"294911911\",\"BZ\":\"6221234\",\"CA\":\"5062345678\",\"CC\":\"412345678\",\"CD\":\"991234567\",\"CF\":\"70012345\",\"CG\":\"061234567\",\"CH\":\"781234567\",\"CI\":\"0123456789\",\"CK\":\"71234\",\"CL\":\"221234567\",\"CM\":\"671234567\",\"CN\":\"13123456789\",\"CO\":\"3211234567\",\"CR\":\"83123456\",\"CU\":\"51234567\",\"CV\":\"9911234\",\"CW\":\"95181234\",\"CX\":\"412345678\",\"CY\":\"96123456\",\"CZ\":\"601123456\",\"DE\":\"15123456789\",\"DJ\":\"77831001\",\"DK\":\"34412345\",\"DM\":\"7672251234\",\"DO\":\"8092345678\",\"DZ\":\"551234567\",\"EC\":\"991234567\",\"EE\":\"51234567\",\"EG\":\"1001234567\",\"EH\":\"650123456\",\"ER\":\"7123456\",\"ES\":\"612345678\",\"ET\":\"911234567\",\"FI\":\"412345678\",\"FJ\":\"7012345\",\"FK\":\"51234\",\"FM\":\"3501234\",\"FO\":\"211234\",\"FR\":\"612345678\",\"GA\":\"06031234\",\"GB\":\"7400123456\",\"GD\":\"4734031234\",\"GE\":\"555123456\",\"GF\":\"694201234\",\"GG\":\"7781123456\",\"GH\":\"231234567\",\"GI\":\"57123456\",\"GL\":\"221234\",\"GM\":\"3012345\",\"GN\":\"601123456\",\"GP\":\"690001234\",\"GQ\":\"222123456\",\"GR\":\"6912345678\",\"GT\":\"51234567\",\"GU\":\"6713001234\",\"GW\":\"955012345\",\"GY\":\"6091234\",\"HK\":\"51234567\",\"HN\":\"91234567\",\"HR\":\"921234567\",\"HT\":\"34101234\",\"HU\":\"201234567\",\"ID\":\"812345678\",\"IE\":\"850123456\",\"IL\":\"502345678\",\"IM\":\"7924123456\",\"IN\":\"8123456789\",\"IO\":\"3801234\",\"IQ\":\"7912345678\",\"IR\":\"9123456789\",\"IS\":\"6111234\",\"IT\":\"3123456789\",\"JE\":\"7797712345\",\"JM\":\"8762101234\",\"JO\":\"790123456\",\"JP\":\"9012345678\",\"KE\":\"712123456\",\"KG\":\"700123456\",\"KH\":\"91234567\",\"KI\":\"72001234\",\"KM\":\"3212345\",\"KN\":\"8697652917\",\"KP\":\"1921234567\",\"KR\":\"1020000000\",\"KW\":\"50012345\",\"KY\":\"3453231234\",\"KZ\":\"7710009998\",\"LA\":\"2023123456\",\"LB\":\"71123456\",\"LC\":\"7582845678\",\"LI\":\"660234567\",\"LK\":\"712345678\",\"LR\":\"770123456\",\"LS\":\"50123456\",\"LT\":\"61234567\",\"LU\":\"628123456\",\"LV\":\"21234567\",\"LY\":\"912345678\",\"MA\":\"650123456\",\"MC\":\"612345678\",\"MD\":\"62112345\",\"ME\":\"60123456\",\"MF\":\"690001234\",\"MG\":\"321234567\",\"MH\":\"2351234\",\"MK\":\"72345678\",\"ML\":\"65012345\",\"MM\":\"92123456\",\"MN\":\"88123456\",\"MO\":\"66123456\",\"MP\":\"6702345678\",\"MQ\":\"696201234\",\"MR\":\"22123456\",\"MS\":\"6644923456\",\"MT\":\"96961234\",\"MU\":\"52512345\",\"MV\":\"7712345\",\"MW\":\"991234567\",\"MX\":\"2221234567\",\"MY\":\"123456789\",\"MZ\":\"821234567\",\"NA\":\"811234567\",\"NC\":\"751234\",\"NE\":\"93123456\",\"NF\":\"381234\",\"NG\":\"8021234567\",\"NI\":\"81234567\",\"NL\":\"612345678\",\"NO\":\"40612345\",\"NP\":\"9841234567\",\"NR\":\"5551234\",\"NU\":\"8884012\",\"NZ\":\"211234567\",\"OM\":\"92123456\",\"PA\":\"61234567\",\"PE\":\"912345678\",\"PF\":\"87123456\",\"PG\":\"70123456\",\"PH\":\"9051234567\",\"PK\":\"3012345678\",\"PL\":\"512345678\",\"PM\":\"551234\",\"PR\":\"7872345678\",\"PS\":\"599123456\",\"PT\":\"912345678\",\"PW\":\"6201234\",\"PY\":\"961456789\",\"QA\":\"33123456\",\"RE\":\"692123456\",\"RO\":\"712034567\",\"RS\":\"601234567\",\"RU\":\"9123456789\",\"RW\":\"720123456\",\"SA\":\"512345678\",\"SB\":\"7421234\",\"SC\":\"2510123\",\"SD\":\"911231234\",\"SE\":\"701234567\",\"SG\":\"81234567\",\"SH\":\"51234\",\"SI\":\"31234567\",\"SJ\":\"41234567\",\"SK\":\"912123456\",\"SL\":\"25123456\",\"SM\":\"66661212\",\"SN\":\"701234567\",\"SO\":\"71123456\",\"SR\":\"7412345\",\"SS\":\"977123456\",\"ST\":\"9812345\",\"SV\":\"70123456\",\"SX\":\"7215205678\",\"SY\":\"944567890\",\"SZ\":\"76123456\",\"TA\":\"8999\",\"TC\":\"6492311234\",\"TD\":\"63012345\",\"TG\":\"90112345\",\"TH\":\"812345678\",\"TJ\":\"917123456\",\"TK\":\"7290\",\"TL\":\"77212345\",\"TM\":\"66123456\",\"TN\":\"20123456\",\"TO\":\"7715123\",\"TR\":\"5012345678\",\"TT\":\"8682911234\",\"TV\":\"901234\",\"TW\":\"912345678\",\"TZ\":\"621234567\",\"UA\":\"501234567\",\"UG\":\"712345678\",\"US\":\"2015550123\",\"UY\":\"94231234\",\"UZ\":\"912345678\",\"VA\":\"3123456789\",\"VC\":\"7844301234\",\"VE\":\"4121234567\",\"VG\":\"2843001234\",\"VI\":\"3406421234\",\"VN\":\"912345678\",\"VU\":\"5912345\",\"WF\":\"821234\",\"WS\":\"7212345\",\"XK\":\"43201234\",\"YE\":\"712345678\",\"YT\":\"639012345\",\"ZA\":\"711234567\",\"ZM\":\"955123456\",\"ZW\":\"712345678\"}","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// This \"state\" object simply holds the state of the \"AsYouType\" parser:\n//\n// * `country?: string` — The exact country of the phone number, if it could be determined.\n//                        When inputting a phone number in \"international\" format, it will derive the `country` from \"country calling code\" and the phone number digits.\n//                        When inputting a phone number in \"national\" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.\n//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for \"non-geographic phone numbers\" `state.country` would've been \"001\".\n// * `callingCode?: string` — \"Country calling code\" that has been extracted from the input phone number.\n//                        When inputting a phone number in \"international\" format, it will extract the \"country calling code\" from the digits that follow the \"+\" character.\n//                        When inputting a phone number in \"national\" format, `callingCode` will be `undefined`.\n//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not — that would be when inputting a phone number not in \"international\" format.\n// * `digits: string` — Phone number digits that have been input so far, including the \"+\" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.\n// * `international: boolean` — Whether the phone number is being input in \"international\" format, i.e. with a \"+\" character.\n// * `missingPlus: boolean` — Whether it's a phone number in \"international\" format that is missing the leading \"+\" character for some reason — apparently, Google thinks that it's a common mistake when inputting a phone number.\n// * `IDDPrefix?: string` — An \"IDD prefix\", when the phone number is being input in an \"out-of-country dialing\" format. https://wikitravel.org/en/International_dialling_prefix\n// * `carrierCode?: string` — A \"carrier code\", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.\n// * `nationalPrefix?: string` — \"National prefix\", if present in the phone number input.\n// * `nationalSignificantNumber?: string` — National (significant) number digits that have been input so far.\n// * `nationalSignificantNumberIsModified: boolean` — Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting \"0343515551212999\" Argentinian mobile number, the parsed national (significant) number is \"93435551212999\". There, one can see how it stripped \"0\" national prefix and prepended a \"9\", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's \"modified\" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string` — In some countries, a phone number could have a prefix that is not a \"national prefix\" but rather some other type of \"utility\" prefix.\n//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.\n//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n//\nvar AsYouTypeState = /*#__PURE__*/function () {\n  function AsYouTypeState(_ref) {\n    var onCountryChange = _ref.onCountryChange,\n      onCallingCodeChange = _ref.onCallingCodeChange;\n    _classCallCheck(this, AsYouTypeState);\n    this.onCountryChange = onCountryChange;\n    this.onCallingCodeChange = onCallingCodeChange;\n  }\n  return _createClass(AsYouTypeState, [{\n    key: \"reset\",\n    value: function reset(_ref2) {\n      var country = _ref2.country,\n        callingCode = _ref2.callingCode;\n      this.international = false;\n      this.missingPlus = false;\n      this.IDDPrefix = undefined;\n      this.callingCode = undefined;\n      this.digits = '';\n      this.resetNationalSignificantNumber();\n      this.initCountryAndCallingCode(country, callingCode);\n    }\n  }, {\n    key: \"resetNationalSignificantNumber\",\n    value: function resetNationalSignificantNumber() {\n      this.nationalSignificantNumber = this.getNationalDigits();\n      this.nationalSignificantNumberIsModified = false;\n      this.nationalPrefix = undefined;\n      this.carrierCode = undefined;\n      this.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined;\n    }\n  }, {\n    key: \"update\",\n    value: function update(properties) {\n      for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        this[key] = properties[key];\n      }\n    }\n  }, {\n    key: \"initCountryAndCallingCode\",\n    value: function initCountryAndCallingCode(country, callingCode) {\n      this.setCountry(country);\n      this.setCallingCode(callingCode);\n    }\n  }, {\n    key: \"setCountry\",\n    value: function setCountry(country) {\n      this.country = country;\n      this.onCountryChange(country);\n    }\n  }, {\n    key: \"setCallingCode\",\n    value: function setCallingCode(callingCode) {\n      this.callingCode = callingCode;\n      this.onCallingCodeChange(callingCode, this.country);\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(country, callingCode) {\n      // Prepend the `+` to parsed input.\n      this.international = true;\n      // If a default country was set then reset it\n      // because an explicitly international phone\n      // number is being entered.\n      this.initCountryAndCallingCode(country, callingCode);\n    }\n  }, {\n    key: \"appendDigits\",\n    value: function appendDigits(nextDigits) {\n      this.digits += nextDigits;\n    }\n  }, {\n    key: \"appendNationalSignificantNumberDigits\",\n    value: function appendNationalSignificantNumberDigits(nextDigits) {\n      this.nationalSignificantNumber += nextDigits;\n    }\n\n    /**\r\n     * Returns the part of `this.digits` that corresponds to the national number.\r\n     * Basically, all digits that have been input by the user, except for the\r\n     * international prefix and the country calling code part\r\n     * (if the number is an international one).\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getNationalDigits\",\n    value: function getNationalDigits() {\n      if (this.international) {\n        return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));\n      }\n      return this.digits;\n    }\n  }, {\n    key: \"getDigitsWithoutInternationalPrefix\",\n    value: function getDigitsWithoutInternationalPrefix() {\n      if (this.international) {\n        if (this.IDDPrefix) {\n          return this.digits.slice(this.IDDPrefix.length);\n        }\n      }\n      return this.digits;\n    }\n  }]);\n}();\nexport { AsYouTypeState as default };\n//# sourceMappingURL=AsYouTypeState.js.map","function _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);\n\n// Counts all occurences of a symbol in a string.\n// Unicode-unsafe (because using `.split()`).\nexport function countOccurences(symbol, string) {\n  var count = 0;\n  // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for counting brackets it is safe.\n  // for (const character of string)\n  for (var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;) {\n    var character = _step.value;\n    if (character === symbol) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n  var result = '';\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n    times >>= 1;\n    string += string;\n  }\n  return result + string;\n}\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\n  if (string[cutBeforeIndex] === ')') {\n    cutBeforeIndex++;\n  }\n  return stripNonPairedParens(string.slice(0, cutBeforeIndex));\n}\nexport function closeNonPairedParens(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = countOccurences('(', retained_template);\n  var closing_braces = countOccurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n    cut_before++;\n  }\n  return template.slice(0, cut_before);\n}\nexport function stripNonPairedParens(string) {\n  var dangling_braces = [];\n  var i = 0;\n  while (i < string.length) {\n    if (string[i] === '(') {\n      dangling_braces.push(i);\n    } else if (string[i] === ')') {\n      dangling_braces.pop();\n    }\n    i++;\n  }\n  var start = 0;\n  var cleared_string = '';\n  dangling_braces.push(string.length);\n  for (var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++) {\n    var index = _dangling_braces[_i];\n    cleared_string += string.slice(start, index);\n    start = index + 1;\n  }\n  return cleared_string;\n}\nexport function populateTemplateWithDigits(template, position, digits) {\n  // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for `digits` it is safe.\n  // for (const digit of digits)\n  for (var _iterator2 = _createForOfIteratorHelperLoose(digits.split('')), _step2; !(_step2 = _iterator2()).done;) {\n    var digit = _step2.value;\n    // If there is room for more digits in current `template`,\n    // then set the next digit in the `template`,\n    // and return the formatted digits so far.\n    // If more digits are entered than the current format could handle.\n    if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\n      return;\n    }\n    position = template.search(DIGIT_PLACEHOLDER_MATCHER);\n    template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n  }\n  return [template, position];\n}\n//# sourceMappingURL=AsYouTypeFormatter.util.js.map","import checkNumberLength from './helpers/checkNumberLength.js';\nimport parseDigits from './helpers/parseDigits.js';\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js';\nexport default function formatCompleteNumber(state, format, _ref) {\n  var metadata = _ref.metadata,\n    shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule,\n    getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;\n  var matcher = new RegExp(\"^(?:\".concat(format.pattern(), \")$\"));\n  if (matcher.test(state.nationalSignificantNumber)) {\n    return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {\n      metadata: metadata,\n      shouldTryNationalPrefixFormattingRule: shouldTryNationalPrefixFormattingRule,\n      getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix\n    });\n  }\n}\nexport function canFormatCompleteNumber(nationalSignificantNumber, country, metadata) {\n  return checkNumberLength(nationalSignificantNumber, country, metadata) === 'IS_POSSIBLE';\n}\nfunction formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, _ref2) {\n  var metadata = _ref2.metadata,\n    shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule,\n    getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;\n  // `format` has already been checked for `nationalPrefix` requirement.\n\n  var nationalSignificantNumber = state.nationalSignificantNumber,\n    international = state.international,\n    nationalPrefix = state.nationalPrefix,\n    carrierCode = state.carrierCode;\n\n  // Format the number with using `national_prefix_formatting_rule`.\n  // If the resulting formatted number is a valid formatted number, then return it.\n  //\n  // Google's AsYouType formatter is different in a way that it doesn't try\n  // to format using the \"national prefix formatting rule\", and instead it\n  // simply prepends a national prefix followed by a \" \" character.\n  // This code does that too, but as a fallback.\n  // The reason is that \"national prefix formatting rule\" may use parentheses,\n  // which wouldn't be included has it used the simpler Google's way.\n  //\n  if (shouldTryNationalPrefixFormattingRule(format)) {\n    var formattedNumber = formatNationalNumber(state, format, {\n      useNationalPrefixFormattingRule: true,\n      getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,\n      metadata: metadata\n    });\n    if (formattedNumber) {\n      return formattedNumber;\n    }\n  }\n\n  // Format the number without using `national_prefix_formatting_rule`.\n  return formatNationalNumber(state, format, {\n    useNationalPrefixFormattingRule: false,\n    getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,\n    metadata: metadata\n  });\n}\nfunction formatNationalNumber(state, format, _ref3) {\n  var metadata = _ref3.metadata,\n    useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule,\n    getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;\n  var formattedNationalNumber = formatNationalNumberUsingFormat(state.nationalSignificantNumber, format, {\n    carrierCode: state.carrierCode,\n    useInternationalFormat: state.international,\n    withNationalPrefix: useNationalPrefixFormattingRule,\n    metadata: metadata\n  });\n  if (!useNationalPrefixFormattingRule) {\n    if (state.nationalPrefix) {\n      // If a national prefix was extracted, then just prepend it,\n      // followed by a \" \" character.\n      formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;\n    } else if (state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\n      formattedNationalNumber = state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix + ' ' + formattedNationalNumber;\n    }\n  }\n  if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {\n    return formattedNationalNumber;\n  }\n}\n\n// Check that the formatted phone number contains exactly\n// the same digits that have been input by the user.\n// For example, when \"0111523456789\" is input for `AR` country,\n// the extracted `this.nationalSignificantNumber` is \"91123456789\",\n// which means that the national part of `this.digits` isn't simply equal to\n// `this.nationalPrefix` + `this.nationalSignificantNumber`.\n//\n// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`\n// being formatted via `metadata[country].national_prefix_transform_rule`.\n// For example, for `VI` country, it prepends `340` to the national number,\n// and if this check hasn't been implemented, then there would be a bug\n// when `340` \"area coude\" is \"duplicated\" during input for `VI` country:\n// https://github.com/catamphetamine/libphonenumber-js/issues/318\n//\n// So, all these \"gotchas\" are filtered out.\n//\n// In the original Google's code, the comments say:\n// \"Check that we didn't remove nor add any extra digits when we matched\n// this formatting pattern. This usually happens after we entered the last\n// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\n// formatted but AYTF should retain all the number entered and not change\n// in order to match a format (of same leading digits and length) display\n// in that way.\"\n// \"If it's the same (i.e entered number and format is same), then it's\n// safe to return this in formatted number as nothing is lost / added.\"\n// Otherwise, don't use this format.\n// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\n// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\n//\nfunction isValidFormattedNationalNumber(formattedNationalNumber, state) {\n  return parseDigits(formattedNationalNumber) === state.getNationalDigits();\n}\n//# sourceMappingURL=AsYouTypeFormatter.complete.js.map","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n  return _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n      var _this$context$ = this.context[0],\n        branches = _this$context$.branches,\n        instructions = _this$context$.instructions;\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n\n      /* istanbul ignore if */\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n      var match = pattern.match(OPERATOR);\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n          if (before) {\n            this.parsePattern(before);\n          }\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n          var _this$getContext = this.getContext(),\n            branches = _this$getContext.branches;\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n          if (before) {\n            this.parsePattern(before);\n          }\n          // The top-level is an implicit \"or\" group, if required.\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n}();\nexport { PatternParser as default };\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n    i++;\n  }\n  return values;\n}\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp(\n// any of:\n'(' +\n// or operator\n'\\\\|' +\n// or\n'|' +\n// or group start\n'\\\\(\\\\?\\\\:' +\n// or\n'|' +\n// or group end\n'\\\\)' +\n// or\n'|' +\n// one-of set start\n'\\\\[' +\n// or\n'|' +\n// one-of set end\n'\\\\]' + ')');\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n  return array;\n}\n//# sourceMappingURL=AsYouTypeFormatter.PatternParser.js.map","function _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport PatternParser from './AsYouTypeFormatter.PatternParser.js';\nvar PatternMatcher = /*#__PURE__*/function () {\n  function PatternMatcher(pattern) {\n    _classCallCheck(this, PatternMatcher);\n    this.matchTree = new PatternParser().parse(pattern);\n  }\n  return _createClass(PatternMatcher, [{\n    key: \"match\",\n    value: function match(string) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        allowOverflow = _ref.allowOverflow;\n      if (!string) {\n        throw new Error('String is required');\n      }\n      var result = _match(string.split(''), this.matchTree, true);\n      if (result && result.match) {\n        delete result.matchedChars;\n      }\n      if (result && result.overflow) {\n        if (!allowOverflow) {\n          return;\n        }\n      }\n      return result;\n    }\n  }]);\n}();\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\nexport { PatternMatcher as default };\nfunction _match(characters, tree, last) {\n  // If `tree` is a string, then `tree` is a single character.\n  // That's because when a pattern is parsed, multi-character-string parts\n  // of a pattern are compiled into arrays of single characters.\n  // I still wrote this piece of code for a \"general\" hypothetical case\n  // when `tree` could be a string of several characters, even though\n  // such case is not possible with the current implementation.\n  if (typeof tree === 'string') {\n    var characterString = characters.join('');\n    if (tree.indexOf(characterString) === 0) {\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n      /* istanbul ignore else */\n      if (characters.length === tree.length) {\n        return {\n          match: true,\n          matchedChars: characters\n        };\n      }\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n      /* istanbul ignore next */\n      return {\n        partialMatch: true\n        // matchedChars: characters\n      };\n    }\n    if (characterString.indexOf(tree) === 0) {\n      if (last) {\n        // The `else` path is not possible because `tree` is always a single character.\n        // The `else` case for `characters.length > tree.length` would be\n        // `characters.length <= tree.length` which means `characters.length <= 1`.\n        // `characters` array can't be empty, so that means `characters === [tree]`,\n        // which would also mean `tree.indexOf(characterString) === 0` and that'd mean\n        // that the `if (tree.indexOf(characterString) === 0)` condition before this\n        // `if` condition would be entered, and returned from there, not reaching this code.\n        /* istanbul ignore else */\n        if (characters.length > tree.length) {\n          return {\n            overflow: true\n          };\n        }\n      }\n      return {\n        match: true,\n        matchedChars: characters.slice(0, tree.length)\n      };\n    }\n    return;\n  }\n  if (Array.isArray(tree)) {\n    var restCharacters = characters.slice();\n    var i = 0;\n    while (i < tree.length) {\n      var subtree = tree[i];\n      var result = _match(restCharacters, subtree, last && i === tree.length - 1);\n      if (!result) {\n        return;\n      } else if (result.overflow) {\n        return result;\n      } else if (result.match) {\n        // Continue with the next subtree with the rest of the characters.\n        restCharacters = restCharacters.slice(result.matchedChars.length);\n        if (restCharacters.length === 0) {\n          if (i === tree.length - 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          } else {\n            return {\n              partialMatch: true\n              // matchedChars: characters\n            };\n          }\n        }\n      } else {\n        /* istanbul ignore else */\n        if (result.partialMatch) {\n          return {\n            partialMatch: true\n            // matchedChars: characters\n          };\n        } else {\n          throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(result, null, 2)));\n        }\n      }\n      i++;\n    }\n    // If `last` then overflow has already been checked\n    // by the last element of the `tree` array.\n    /* istanbul ignore if */\n    if (last) {\n      return {\n        overflow: true\n      };\n    }\n    return {\n      match: true,\n      matchedChars: characters.slice(0, characters.length - restCharacters.length)\n    };\n  }\n  switch (tree.op) {\n    case '|':\n      var partialMatch;\n      for (var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;) {\n        var branch = _step.value;\n        var _result = _match(characters, branch, last);\n        if (_result) {\n          if (_result.overflow) {\n            return _result;\n          } else if (_result.match) {\n            return {\n              match: true,\n              matchedChars: _result.matchedChars\n            };\n          } else {\n            /* istanbul ignore else */\n            if (_result.partialMatch) {\n              partialMatch = true;\n            } else {\n              throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(_result, null, 2)));\n            }\n          }\n        }\n      }\n      if (partialMatch) {\n        return {\n          partialMatch: true\n          // matchedChars: ...\n        };\n      }\n      // Not even a partial match.\n      return;\n    case '[]':\n      for (var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;) {\n        var _char = _step2.value;\n        if (characters[0] === _char) {\n          if (characters.length === 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          }\n          if (last) {\n            return {\n              overflow: true\n            };\n          }\n          return {\n            match: true,\n            matchedChars: [_char]\n          };\n        }\n      }\n      // No character matches.\n      return;\n\n    /* istanbul ignore next */\n    default:\n      throw new Error(\"Unsupported instruction tree: \".concat(tree));\n  }\n}\n//# sourceMappingURL=AsYouTypeFormatter.PatternMatcher.js.map","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { DIGIT_PLACEHOLDER, countOccurences, repeat, cutAndStripNonPairedParens, closeNonPairedParens, stripNonPairedParens, populateTemplateWithDigits } from './AsYouTypeFormatter.util.js';\nimport formatCompleteNumber, { canFormatCompleteNumber } from './AsYouTypeFormatter.complete.js';\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js';\nimport parseDigits from './helpers/parseDigits.js';\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js';\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js';\nimport { VALID_PUNCTUATION } from './constants.js';\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js';\n\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nvar DUMMY_DIGIT = '9';\n// I don't know why is it exactly `15`\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;\n// Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);\n\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\n// us that we should separate the national prefix from the number when formatting.\nvar NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;\n\n// Deprecated: Google has removed some formatting pattern related code from their repo.\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\n// Because this library supports generating custom metadata\n// some users may still be using old metadata so the relevant\n// code seems to stay until some next major version update.\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true;\n\n// A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\[([^\\[\\]])*\\]/g;\n};\n\n// Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\d(?=[^,}][^,}])/g;\n};\n\n// A regular expression that is used to determine if a `format` is\n// suitable to be used in the \"as you type formatter\".\n// A `format` is suitable when the resulting formatted number has\n// the same digits as the user has entered.\n//\n// In the simplest case, that would mean that the format\n// doesn't add any additional digits when formatting a number.\n// Google says that it also shouldn't add \"star\" (`*`) characters,\n// like it does in some Israeli formats.\n// Such basic format would only contain \"valid punctuation\"\n// and \"captured group\" identifiers ($1, $2, etc).\n//\n// An example of a format that adds additional digits:\n//\n// Country: `AR` (Argentina).\n// Format:\n// {\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n//    \"leading_digits_patterns\": [\"91\"],\n//    \"national_prefix_formatting_rule\": \"0$1\",\n//    \"format\": \"$2 15-$3-$4\",\n//    \"international_format\": \"$1 $2 $3-$4\"\n// }\n//\n// In the format above, the `format` adds `15` to the digits when formatting a number.\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\n// has previously removed `15` from a national number, so re-adding `15` in `format`\n// doesn't actually result in any extra digits added to user's input.\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\n//\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\n// `libphonenumber` code.\n//\nvar NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + VALID_PUNCTUATION + ']*' +\n// Google developers say:\n// \"We require that the first matching group is present in the\n//  output pattern to ensure no data is lost while formatting.\"\n'\\\\$1' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' + '$');\n\n// This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\nvar MIN_LEADING_DIGITS_LENGTH = 3;\nvar AsYouTypeFormatter = /*#__PURE__*/function () {\n  function AsYouTypeFormatter(_ref) {\n    var state = _ref.state,\n      metadata = _ref.metadata;\n    _classCallCheck(this, AsYouTypeFormatter);\n    this.metadata = metadata;\n    this.resetFormat();\n  }\n  return _createClass(AsYouTypeFormatter, [{\n    key: \"resetFormat\",\n    value: function resetFormat() {\n      this.chosenFormat = undefined;\n      this.template = undefined;\n      this.nationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplatePosition = -1;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan, state) {\n      this.resetFormat();\n      if (numberingPlan) {\n        this.isNANP = numberingPlan.callingCode() === '1';\n        this.matchingFormats = numberingPlan.formats();\n        if (state.nationalSignificantNumber) {\n          this.narrowDownMatchingFormats(state);\n        }\n      } else {\n        this.isNANP = undefined;\n        this.matchingFormats = [];\n      }\n    }\n\n    /**\r\n     * Formats an updated phone number.\r\n     * @param  {string} nextDigits — Additional phone number digits.\r\n     * @param  {object} state — `AsYouType` state.\r\n     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n     */\n  }, {\n    key: \"format\",\n    value: function format(nextDigits, state) {\n      var _this = this;\n      // See if the phone number digits can be formatted as a complete phone number.\n      // If not, use the results from `formatNationalNumberWithNextDigits()`,\n      // which formats based on the chosen formatting pattern.\n      //\n      // Attempting to format complete phone number first is how it's done\n      // in Google's `libphonenumber`, so this library just follows it.\n      // Google's `libphonenumber` code doesn't explain in detail why does it\n      // attempt to format digits as a complete phone number\n      // instead of just going with a previoulsy (or newly) chosen `format`:\n      //\n      // \"Checks to see if there is an exact pattern match for these digits.\n      //  If so, we should use this instead of any other formatting template\n      //  whose leadingDigitsPattern also matches the input.\"\n      //\n      if (canFormatCompleteNumber(state.nationalSignificantNumber, state.country, this.metadata)) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\n          var _format = _step.value;\n          var formattedCompleteNumber = formatCompleteNumber(state, _format, {\n            metadata: this.metadata,\n            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {\n              return _this.shouldTryNationalPrefixFormattingRule(format, {\n                international: state.international,\n                nationalPrefix: state.nationalPrefix\n              });\n            },\n            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {\n              return _this.getSeparatorAfterNationalPrefix(format);\n            }\n          });\n          if (formattedCompleteNumber) {\n            this.resetFormat();\n            this.chosenFormat = _format;\n            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state);\n            this.populatedNationalNumberTemplate = formattedCompleteNumber;\n            // With a new formatting template, the matched position\n            // using the old template needs to be reset.\n            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER);\n            return formattedCompleteNumber;\n          }\n        }\n      }\n      // Format the digits as a partial (incomplete) phone number\n      // using the previously chosen formatting pattern (or a newly chosen one).\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\n    }\n\n    // Formats the next phone number digits.\n  }, {\n    key: \"formatNationalNumberWithNextDigits\",\n    value: function formatNationalNumberWithNextDigits(nextDigits, state) {\n      var previouslyChosenFormat = this.chosenFormat;\n\n      // Choose a format from the list of matching ones.\n      var newlyChosenFormat = this.chooseFormat(state);\n      if (newlyChosenFormat) {\n        if (newlyChosenFormat === previouslyChosenFormat) {\n          // If it can format the next (current) digits\n          // using the previously chosen phone number format\n          // then return the updated formatted number.\n          return this.formatNextNationalNumberDigits(nextDigits);\n        } else {\n          // If a more appropriate phone number format\n          // has been chosen for these \"leading digits\",\n          // then re-format the national phone number part\n          // using the newly selected format.\n          return this.formatNextNationalNumberDigits(state.getNationalDigits());\n        }\n      }\n    }\n  }, {\n    key: \"narrowDownMatchingFormats\",\n    value: function narrowDownMatchingFormats(_ref2) {\n      var _this2 = this;\n      var nationalSignificantNumber = _ref2.nationalSignificantNumber,\n        nationalPrefix = _ref2.nationalPrefix,\n        international = _ref2.international;\n      var leadingDigits = nationalSignificantNumber;\n\n      // \"leading digits\" pattern list starts with a\n      // \"leading digits\" pattern fitting a maximum of 3 leading digits.\n      // So, after a user inputs 3 digits of a national (significant) phone number\n      // this national (significant) number can already be formatted.\n      // The next \"leading digits\" pattern is for 4 leading digits max,\n      // and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\n\n      // This implementation is different from Google's\n      // in that it searches for a fitting format\n      // even if the user has entered less than\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\n      // Because some leading digit patterns already match for a single first digit.\n      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;\n      if (leadingDigitsPatternIndex < 0) {\n        leadingDigitsPatternIndex = 0;\n      }\n      this.matchingFormats = this.matchingFormats.filter(function (format) {\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\n      });\n\n      // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      // To construct a valid test case for this one can find a country\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\n      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\n        this.resetFormat();\n      }\n    }\n  }, {\n    key: \"formatSuits\",\n    value: function formatSuits(format, international, nationalPrefix) {\n      // When a prefix before a national (significant) number is\n      // simply a national prefix, then it's parsed as `this.nationalPrefix`.\n      // In more complex cases, a prefix before national (significant) number\n      // could include a national prefix as well as some \"capturing groups\",\n      // and in that case there's no info whether a national prefix has been parsed.\n      // If national prefix is not used when formatting a phone number\n      // using this format, but a national prefix has been entered by the user,\n      // and was extracted, then discard such phone number format.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\n      if (nationalPrefix && !format.usesNationalPrefix() &&\n      // !format.domesticCarrierCodeFormattingRule() &&\n      !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n        return false;\n      }\n      // If national prefix is mandatory for this phone number format\n      // and there're no guarantees that a national prefix is present in user input\n      // then discard this phone number format as not suitable.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\n      if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"formatMatches\",\n    value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;\n\n      // If this format is not restricted to a certain\n      // leading digits pattern then it fits.\n      // The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\n      if (leadingDigitsPatternsCount === 0) {\n        return true;\n      }\n\n      // Start narrowing down the list of possible formats based on the leading digits.\n      // (only previously matched formats take part in the narrowing down process)\n\n      // `leading_digits_patterns` start with 3 digits min\n      // and then go up from there one digit at a time.\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\n      var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];\n\n      // Google imposes a requirement on the leading digits\n      // to be minimum 3 digits long in order to be eligible\n      // for checking those with a leading digits pattern.\n      //\n      // Since `leading_digits_patterns` start with 3 digits min,\n      // Google's original `libphonenumber` library only starts\n      // excluding any non-matching formats only when the\n      // national number entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives.\n      //\n      // For example, when the digits entered so far are `2`\n      // and the leading digits pattern is `21` –\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Also, `leading_digits_patterns` doesn't always correspond to a single\n      // digits count. For example, `60|8` pattern would already match `8`\n      // but the `60` part would require having at least two leading digits,\n      // so the whole pattern would require inputting two digits first in order to\n      // decide on whether it matches the input, even when the input is \"80\".\n      //\n      // This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`\n      // even when there's only 1 or 2 digits of the national (significant) number.\n      // To do that, it uses a non-strict pattern matcher written specifically for that.\n      //\n      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\n        // Before leading digits < 3 matching was implemented:\n        // return true\n        //\n        // After leading digits < 3 matching was implemented:\n        try {\n          return new PatternMatcher(leadingDigitsPattern).match(leadingDigits, {\n            allowOverflow: true\n          }) !== undefined;\n        } catch (error) /* istanbul ignore next */{\n          // There's a slight possibility that there could be some undiscovered bug\n          // in the pattern matcher code. Since the \"leading digits < 3 matching\"\n          // feature is not \"essential\" for operation, it can fall back to the old way\n          // in case of any issues rather than halting the application's execution.\n          console.error(error);\n          return true;\n        }\n      }\n\n      // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\n      // available then use the usual regular expression matching.\n      //\n      // The whole pattern is wrapped in round brackets (`()`) because\n      // the pattern can use \"or\" operator (`|`) at the top level of the pattern.\n      //\n      return new RegExp(\"^(\".concat(leadingDigitsPattern, \")\")).test(leadingDigits);\n    }\n  }, {\n    key: \"getFormatFormat\",\n    value: function getFormatFormat(format, international) {\n      return international ? format.internationalFormat() : format.format();\n    }\n  }, {\n    key: \"chooseFormat\",\n    value: function chooseFormat(state) {\n      var _this3 = this;\n      var _loop = function _loop() {\n          var format = _step2.value;\n          // If this format is currently being used\n          // and is still suitable, then stick to it.\n          if (_this3.chosenFormat === format) {\n            return 0; // break\n          }\n          // Sometimes, a formatting rule inserts additional digits in a phone number,\n          // and \"as you type\" formatter can't do that: it should only use the digits\n          // that the user has input.\n          //\n          // For example, in Argentina, there's a format for mobile phone numbers:\n          //\n          // {\n          //    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n          //    \"leading_digits_patterns\": [\"91\"],\n          //    \"national_prefix_formatting_rule\": \"0$1\",\n          //    \"format\": \"$2 15-$3-$4\",\n          //    \"international_format\": \"$1 $2 $3-$4\"\n          // }\n          //\n          // In that format, `international_format` is used instead of `format`\n          // because `format` inserts `15` in the formatted number,\n          // and `AsYouType` formatter should only use the digits\n          // the user has actually input, without adding any extra digits.\n          // In this case, it wouldn't make a difference, because the `15`\n          // is first stripped when applying `national_prefix_for_parsing`\n          // and then re-added when using `format`, so in reality it doesn't\n          // add any new digits to the number, but to detect that, the code\n          // would have to be more complex: it would have to try formatting\n          // the digits using the format and then see if any digits have\n          // actually been added or removed, and then, every time a new digit\n          // is input, it should re-check whether the chosen format doesn't\n          // alter the digits.\n          //\n          // Google's code doesn't go that far, and so does this library:\n          // it simply requires that a `format` doesn't add any additonal\n          // digits to user's input.\n          //\n          // Also, people in general should move from inputting phone numbers\n          // in national format (possibly with national prefixes)\n          // and use international phone number format instead:\n          // it's a logical thing in the modern age of mobile phones,\n          // globalization and the internet.\n          //\n          /* istanbul ignore if */\n          if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\n            return 1; // continue\n          }\n          if (!_this3.createTemplateForFormat(format, state)) {\n            // Remove the format if it can't generate a template.\n            _this3.matchingFormats = _this3.matchingFormats.filter(function (_) {\n              return _ !== format;\n            });\n            return 1; // continue\n          }\n          _this3.chosenFormat = format;\n          return 0; // break\n        },\n        _ret;\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      //\n      // For some weird reason, `istanbul` says \"else path not taken\"\n      // for the `for of` line below. Supposedly that means that\n      // the loop doesn't ever go over the last element in the list.\n      // That's true because there always is `this.chosenFormat`\n      // when `this.matchingFormats` is non-empty.\n      // And, for some weird reason, it doesn't think that the case\n      // with empty `this.matchingFormats` qualifies for a valid \"else\" path.\n      // So simply muting this `istanbul` warning.\n      // It doesn't skip the contents of the `for of` loop,\n      // it just skips the `for of` line.\n      //\n      /* istanbul ignore next */\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;) {\n        _ret = _loop();\n        if (_ret === 0) break;\n        if (_ret === 1) continue;\n      }\n      if (!this.chosenFormat) {\n        // No format matches the national (significant) phone number.\n        this.resetFormat();\n      }\n      return this.chosenFormat;\n    }\n  }, {\n    key: \"createTemplateForFormat\",\n    value: function createTemplateForFormat(format, state) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n      /* istanbul ignore if */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\n        return;\n      }\n      // Get formatting template for this phone number format\n      var template = this.getTemplateForFormat(format, state);\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (template) {\n        this.setNationalNumberTemplate(template, state);\n        return true;\n      }\n    }\n  }, {\n    key: \"getSeparatorAfterNationalPrefix\",\n    value: function getSeparatorAfterNationalPrefix(format) {\n      // `US` metadata doesn't have a `national_prefix_formatting_rule`,\n      // so the `if` condition below doesn't apply to `US`,\n      // but in reality there shoudl be a separator\n      // between a national prefix and a national (significant) number.\n      // So `US` national prefix separator is a \"special\" \"hardcoded\" case.\n      if (this.isNANP) {\n        return ' ';\n      }\n      // If a `format` has a `national_prefix_formatting_rule`\n      // and that rule has a separator after a national prefix,\n      // then it means that there should be a separator\n      // between a national prefix and a national (significant) number.\n      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\n        return ' ';\n      }\n      // At this point, there seems to be no clear evidence that\n      // there should be a separator between a national prefix\n      // and a national (significant) number. So don't insert one.\n      return '';\n    }\n  }, {\n    key: \"getInternationalPrefixBeforeCountryCallingCode\",\n    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {\n      var IDDPrefix = _ref3.IDDPrefix,\n        missingPlus = _ref3.missingPlus;\n      if (IDDPrefix) {\n        return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';\n      }\n      if (missingPlus) {\n        return '';\n      }\n      return '+';\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(state) {\n      if (!this.template) {\n        return;\n      }\n      // `this.template` holds the template for a \"complete\" phone number.\n      // The currently entered phone number is most likely not \"complete\",\n      // so trim all non-populated digits.\n      var index = -1;\n      var i = 0;\n      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {\n        spacing: false\n      }) : '';\n      while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\n        index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);\n        i++;\n      }\n      return cutAndStripNonPairedParens(this.template, index + 1);\n    }\n  }, {\n    key: \"setNationalNumberTemplate\",\n    value: function setNationalNumberTemplate(template, state) {\n      this.nationalNumberTemplate = template;\n      this.populatedNationalNumberTemplate = template;\n      // With a new formatting template, the matched position\n      // using the old template needs to be reset.\n      this.populatedNationalNumberTemplatePosition = -1;\n      // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n      if (state.international) {\n        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) + repeat(DIGIT_PLACEHOLDER, state.callingCode.length) + ' ' + template;\n      } else {\n        this.template = template;\n      }\n    }\n\n    /**\r\n     * Generates formatting template for a national phone number,\r\n     * optionally containing a national prefix, for a format.\r\n     * @param  {Format} format\r\n     * @param  {string} nationalPrefix\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getTemplateForFormat\",\n    value: function getTemplateForFormat(format, _ref4) {\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber,\n        international = _ref4.international,\n        nationalPrefix = _ref4.nationalPrefix,\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _ref4.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\n      var pattern = format.pattern();\n\n      /* istanbul ignore else */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\n        pattern = pattern\n        // Replace anything in the form of [..] with \\d\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\n        // Replace any standalone digit (not the one in `{}`) with \\d\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d');\n      }\n\n      // Generate a dummy national number (consisting of `9`s)\n      // that fits this format's `pattern`.\n      //\n      // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n      //\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];\n\n      // If the national number entered is too long\n      // for any phone number format, then abort.\n      if (nationalSignificantNumber.length > digits.length) {\n        return;\n      }\n\n      // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n\n      // Below `strictPattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strictPattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.nationalSignificantNumber : `111111111` (9 digits)\n      //\n      // pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // format : `$1 $2 $3`\n      // digits : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `pattern`.\n      //\n      // The fix is, if `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then `this.nationalSignificantNumber`\n      // is used instead of `digits`.\n\n      var strictPattern = new RegExp('^' + pattern + '$');\n      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT);\n\n      // If `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then use it\n      // instead of `digits`.\n      if (strictPattern.test(nationalNumberDummyDigits)) {\n        digits = nationalNumberDummyDigits;\n      }\n      var numberFormat = this.getFormatFormat(format, international);\n      var nationalPrefixIncludedInTemplate;\n\n      // If a user did input a national prefix (and that's guaranteed),\n      // and if a `format` does have a national prefix formatting rule,\n      // then see if that national prefix formatting rule\n      // prepends exactly the same national prefix the user has input.\n      // If that's the case, then use the `format` with the national prefix formatting rule.\n      // Otherwise, use  the `format` without the national prefix formatting rule,\n      // and prepend a national prefix manually to it.\n      if (this.shouldTryNationalPrefixFormattingRule(format, {\n        international: international,\n        nationalPrefix: nationalPrefix\n      })) {\n        var numberFormatWithNationalPrefix = numberFormat.replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());\n        // If `national_prefix_formatting_rule` of a `format` simply prepends\n        // national prefix at the start of a national (significant) number,\n        // then such formatting can be used with `AsYouType` formatter.\n        // There seems to be no `else` case: everywhere in metadata,\n        // national prefix formatting rule is national prefix + $1,\n        // or `($1)`, in which case such format isn't even considered\n        // when the user has input a national prefix.\n        /* istanbul ignore else */\n        if (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\n          numberFormat = numberFormatWithNationalPrefix;\n          nationalPrefixIncludedInTemplate = true;\n          // Replace all digits of the national prefix in the formatting template\n          // with `DIGIT_PLACEHOLDER`s.\n          if (nationalPrefix) {\n            var i = nationalPrefix.length;\n            while (i > 0) {\n              numberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER);\n              i--;\n            }\n          }\n        }\n      }\n\n      // Generate formatting template for this phone number format.\n      var template = digits\n      // Format the dummy phone number according to the format.\n      .replace(new RegExp(pattern), numberFormat)\n      // Replace each dummy digit with a DIGIT_PLACEHOLDER.\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER);\n\n      // If a prefix of a national (significant) number is not as simple\n      // as just a basic national prefix, then just prepend such prefix\n      // before the national (significant) number, optionally spacing\n      // the two with a whitespace.\n      if (!nationalPrefixIncludedInTemplate) {\n        if (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\n          // Prepend the prefix to the template manually.\n          template = repeat(DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) + ' ' + template;\n        } else if (nationalPrefix) {\n          // Prepend national prefix to the template manually.\n          template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;\n        }\n      }\n      if (international) {\n        template = applyInternationalSeparatorStyle(template);\n      }\n      return template;\n    }\n  }, {\n    key: \"formatNextNationalNumberDigits\",\n    value: function formatNextNationalNumberDigits(digits) {\n      var result = populateTemplateWithDigits(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);\n      if (!result) {\n        // Reset the format.\n        this.resetFormat();\n        return;\n      }\n      this.populatedNationalNumberTemplate = result[0];\n      this.populatedNationalNumberTemplatePosition = result[1];\n\n      // Return the formatted phone number so far.\n      return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);\n\n      // The old way which was good for `input-format` but is not so good\n      // for `react-phone-number-input`'s default input (`InputBasic`).\n      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\n      // \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\n    }\n  }, {\n    key: \"shouldTryNationalPrefixFormattingRule\",\n    value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {\n      var international = _ref5.international,\n        nationalPrefix = _ref5.nationalPrefix;\n      if (format.nationalPrefixFormattingRule()) {\n        // In some countries, `national_prefix_formatting_rule` is `($1)`,\n        // so it applies even if the user hasn't input a national prefix.\n        // `format.usesNationalPrefix()` detects such cases.\n        var usesNationalPrefix = format.usesNationalPrefix();\n        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {\n          return true;\n        }\n      }\n    }\n  }]);\n}();\nexport { AsYouTypeFormatter as default };\n//# sourceMappingURL=AsYouTypeFormatter.js.map","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport _extractCountryCallingCode from './helpers/extractCountryCallingCode.js';\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js';\nimport extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js';\nimport stripIddPrefix from './helpers/stripIddPrefix.js';\nimport parseDigits from './helpers/parseDigits.js';\nimport { VALID_DIGITS, VALID_PUNCTUATION, PLUS_CHARS } from './constants.js';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');\nvar VALID_FORMATTED_PHONE_NUMBER_PART = '(?:' + '[' + PLUS_CHARS + ']' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*' + '|' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + ')';\nvar AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + '.*' + '$');\n\n// Tests whether `national_prefix_for_parsing` could match\n// different national prefixes.\n// Matches anything that's not a digit or a square bracket.\nvar COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/;\nvar AsYouTypeParser = /*#__PURE__*/function () {\n  function AsYouTypeParser(_ref) {\n    var defaultCountry = _ref.defaultCountry,\n      defaultCallingCode = _ref.defaultCallingCode,\n      metadata = _ref.metadata,\n      onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;\n    _classCallCheck(this, AsYouTypeParser);\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.metadata = metadata;\n    this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;\n  }\n  return _createClass(AsYouTypeParser, [{\n    key: \"input\",\n    value: function input(text, state) {\n      var _extractFormattedDigi = extractFormattedDigitsAndPlus(text),\n        _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2),\n        formattedDigits = _extractFormattedDigi2[0],\n        hasPlus = _extractFormattedDigi2[1];\n      var digits = parseDigits(formattedDigits);\n      // Checks for a special case: just a leading `+` has been entered.\n      var justLeadingPlus;\n      if (hasPlus) {\n        if (!state.digits) {\n          state.startInternationalNumber(undefined, undefined);\n          if (!digits) {\n            justLeadingPlus = true;\n          }\n        }\n      }\n      if (digits) {\n        this.inputDigits(digits, state);\n      }\n      return {\n        digits: digits,\n        justLeadingPlus: justLeadingPlus\n      };\n    }\n\n    /**\r\n     * Inputs \"next\" phone number digits.\r\n     * @param  {string} digits\r\n     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n     */\n  }, {\n    key: \"inputDigits\",\n    value: function inputDigits(nextDigits, state) {\n      var digits = state.digits;\n      var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;\n\n      // Append phone number digits.\n      state.appendDigits(nextDigits);\n\n      // Attempt to extract IDD prefix:\n      // Some users input their phone number in international format,\n      // but in an \"out-of-country\" dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers as soon as there're at least 3 digits.\n      // Google's library attempts to extract IDD prefix at 3 digits,\n      // so this library just copies that behavior.\n      // I guess that's because the most commot IDD prefixes are\n      // `00` (Europe) and `011` (US).\n      // There exist really long IDD prefixes too:\n      // for example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      // An IDD prefix is extracted here, and then every time when\n      // there's a new digit and the number couldn't be formatted.\n      if (hasReceivedThreeLeadingDigits) {\n        this.extractIddPrefix(state);\n      }\n      if (this.isWaitingForCountryCallingCode(state)) {\n        if (!this.extractCountryCallingCode(state)) {\n          return;\n        }\n      } else {\n        state.appendNationalSignificantNumberDigits(nextDigits);\n      }\n\n      // If a phone number is being input in international format,\n      // then it's not valid for it to have a national prefix.\n      // Still, some people incorrectly input such numbers with a national prefix.\n      // In such cases, only attempt to strip a national prefix if the number becomes too long.\n      // (but that is done later, not here)\n      if (!state.international) {\n        if (!this.hasExtractedNationalSignificantNumber) {\n          this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n            return state.update(stateUpdate);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"isWaitingForCountryCallingCode\",\n    value: function isWaitingForCountryCallingCode(_ref2) {\n      var international = _ref2.international,\n        callingCode = _ref2.callingCode;\n      return international && !callingCode;\n    }\n\n    // Extracts a country calling code from a number\n    // being entered in internatonal format.\n  }, {\n    key: \"extractCountryCallingCode\",\n    value: function extractCountryCallingCode(state) {\n      var _extractCountryCallin = _extractCountryCallingCode('+' + state.getDigitsWithoutInternationalPrefix(), state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n        countryCallingCode = _extractCountryCallin.countryCallingCode,\n        number = _extractCountryCallin.number;\n      if (countryCallingCode) {\n        state.setCallingCode(countryCallingCode);\n        state.update({\n          nationalSignificantNumber: number\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan) {\n      if (numberingPlan) {\n        this.hasSelectedNumberingPlan = true;\n        var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);\n      } else {\n        this.hasSelectedNumberingPlan = undefined;\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;\n      }\n    }\n\n    /**\r\n     * Extracts a national (significant) number from user input.\r\n     * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n     * and doesn't apply `national_prefix_transform_rule` after that.\r\n     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n     * @return {boolean} [extracted]\r\n     */\n  }, {\n    key: \"extractNationalSignificantNumber\",\n    value: function extractNationalSignificantNumber(nationalDigits, setState) {\n      if (!this.hasSelectedNumberingPlan) {\n        return;\n      }\n      var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata),\n        nationalPrefix = _extractNationalNumbe.nationalPrefix,\n        nationalNumber = _extractNationalNumbe.nationalNumber,\n        carrierCode = _extractNationalNumbe.carrierCode;\n      if (nationalNumber === nationalDigits) {\n        return;\n      }\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n\n    /**\r\n     * In Google's code this function is called \"attempt to extract longer NDD\".\r\n     * \"Some national prefixes are a substring of others\", they say.\r\n     * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.\r\n     */\n  }, {\n    key: \"extractAnotherNationalSignificantNumber\",\n    value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\n      if (!this.hasExtractedNationalSignificantNumber) {\n        return this.extractNationalSignificantNumber(nationalDigits, setState);\n      }\n      if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\n        return;\n      }\n      var _extractNationalNumbe2 = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata),\n        nationalPrefix = _extractNationalNumbe2.nationalPrefix,\n        nationalNumber = _extractNationalNumbe2.nationalNumber,\n        carrierCode = _extractNationalNumbe2.carrierCode;\n      // If a national prefix has been extracted previously,\n      // then it's always extracted as additional digits are added.\n      // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\n      // doesn't do anything different from what it currently does.\n      // So, just in case, here's this check, though it doesn't occur.\n      /* istanbul ignore if */\n      if (nationalNumber === prevNationalSignificantNumber) {\n        return;\n      }\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n  }, {\n    key: \"onExtractedNationalNumber\",\n    value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {\n      // Tells if the parsed national (significant) number is present as-is in the input string.\n      // For example, when inputting \"0343515551212999\" Argentinian mobile number,\n      // the parsed national (significant) number is \"93435551212999\".\n      // There, one can see how it stripped \"0\" national prefix and prepended a \"9\",\n      // because that's how it is instructed to do in Argentina's metadata.\n      // So in the described example, the parsed national (significant) number is not present\n      // as-is in the input string. Instead, it's \"modified\" in the input string.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      var nationalSignificantNumberIsModified = false;\n\n      // In some countries, a phone number could have a prefix that is not a \"national prefix\"\n      // but rather some other type of \"utility\" prefix.\n      // For example, when calling within Australia, one could prepend `1831` prefix to hide\n      // caller's phone number.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      var prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;\n\n      // `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.\n      var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);\n\n      // If the parsed national (significant) number is the last substring of the `nationalDigits`,\n      // then it means that it's present as-is in the input string.\n      // In any other case, the parsed national (significant) number is \"modified\" in the input string.\n      if (nationalSignificantNumberIndex < 0 || nationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length) {\n        nationalSignificantNumberIsModified = true;\n      } else {\n        var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);\n        // When national (significant) number is equal to the `nationalDigits`,\n        // this `onExtractedNationalNumber()` function simply doesn't get called.\n        // This means that at this point, `prefixBeforeNationalNumber` is always non-empty.\n        // Still, added this `if` check just to prevent potential silly bugs.\n        // The `!prefixBeforeNationalNumber` case is not really testable\n        // so this line is exluded from the code coverage.\n        /* istanbul ignore if */\n        if (prefixBeforeNationalNumber) {\n          if (prefixBeforeNationalNumber !== nationalPrefix) {\n            prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber;\n          }\n        }\n      }\n      setState({\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode,\n        nationalSignificantNumber: nationalSignificantNumber,\n        nationalSignificantNumberIsModified: nationalSignificantNumberIsModified,\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix: prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\n      });\n      // `onExtractedNationalNumber()` is only called when\n      // the national (significant) number actually did change.\n      this.hasExtractedNationalSignificantNumber = true;\n      this.onNationalSignificantNumberChange();\n    }\n  }, {\n    key: \"reExtractNationalSignificantNumber\",\n    value: function reExtractNationalSignificantNumber(state) {\n      // Attempt to extract a national prefix.\n      //\n      // Some people incorrectly input national prefix\n      // in an international phone number.\n      // For example, some people write British phone numbers as `+44(0)...`.\n      //\n      // Also, in some rare cases, it is valid for a national prefix\n      // to be a part of an international phone number.\n      // For example, mobile phone numbers in Mexico are supposed to be\n      // dialled internationally using a `1` national prefix,\n      // so the national prefix will be part of an international number.\n      //\n      // Quote from:\n      // https://www.mexperience.com/dialing-cell-phones-in-mexico/\n      //\n      // \"Dialing a Mexican cell phone from abroad\n      // When you are calling a cell phone number in Mexico from outside Mexico,\n      // it’s necessary to dial an additional “1” after Mexico’s country code\n      // (which is “52”) and before the area code.\n      // You also ignore the 045, and simply dial the area code and the\n      // cell phone’s number.\n      //\n      // If you don’t add the “1”, you’ll receive a recorded announcement\n      // asking you to redial using it.\n      //\n      // For example, if you are calling from the USA to a cell phone\n      // in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\n      // (Note that this is different to calling a land line in Mexico City\n      // from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\n      //\n      // Google's demo output:\n      // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\n      //\n      if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function (stateUpdate) {\n        return state.update(stateUpdate);\n      })) {\n        return true;\n      }\n      // If no format matches the phone number, then it could be\n      // \"a really long IDD\" (quote from a comment in Google's library).\n      // An IDD prefix is first extracted when the user has entered at least 3 digits,\n      // and then here — every time when there's a new digit and the number\n      // couldn't be formatted.\n      // For example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      //\n      // Could also check `!hasReceivedThreeLeadingDigits` here\n      // to filter out the case when this check duplicates the one\n      // already performed when there're 3 leading digits,\n      // but it's not a big deal, and in most cases there\n      // will be a suitable `format` when there're 3 leading digits.\n      //\n      if (this.extractIddPrefix(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n      // Google's AsYouType formatter supports sort of an \"autocorrection\" feature\n      // when it \"autocorrects\" numbers that have been input for a country\n      // with that country's calling code.\n      // Such \"autocorrection\" feature looks weird, but different people have been requesting it:\n      // https://github.com/catamphetamine/libphonenumber-js/issues/376\n      // https://github.com/catamphetamine/libphonenumber-js/issues/375\n      // https://github.com/catamphetamine/libphonenumber-js/issues/316\n      if (this.fixMissingPlus(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n    }\n  }, {\n    key: \"extractIddPrefix\",\n    value: function extractIddPrefix(state) {\n      // An IDD prefix can't be present in a number written with a `+`.\n      // Also, don't re-extract an IDD prefix if has already been extracted.\n      var international = state.international,\n        IDDPrefix = state.IDDPrefix,\n        digits = state.digits,\n        nationalSignificantNumber = state.nationalSignificantNumber;\n      if (international || IDDPrefix) {\n        return;\n      }\n      // Some users input their phone number in \"out-of-country\"\n      // dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers.\n      var numberWithoutIDD = stripIddPrefix(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);\n      if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\n        // If an IDD prefix was stripped then convert the IDD-prefixed number\n        // to international number for subsequent parsing.\n        state.update({\n          IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\n        });\n        this.startInternationalNumber(state, {\n          country: undefined,\n          callingCode: undefined\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"fixMissingPlus\",\n    value: function fixMissingPlus(state) {\n      if (!state.international) {\n        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(state.digits, state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n          newCallingCode = _extractCountryCallin2.countryCallingCode;\n        if (newCallingCode) {\n          state.update({\n            missingPlus: true\n          });\n          this.startInternationalNumber(state, {\n            country: state.country,\n            callingCode: newCallingCode\n          });\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(state, _ref3) {\n      var country = _ref3.country,\n        callingCode = _ref3.callingCode;\n      state.startInternationalNumber(country, callingCode);\n      // If a national (significant) number has been extracted before, reset it.\n      if (state.nationalSignificantNumber) {\n        state.resetNationalSignificantNumber();\n        this.onNationalSignificantNumberChange();\n        this.hasExtractedNationalSignificantNumber = undefined;\n      }\n    }\n  }, {\n    key: \"extractCallingCodeAndNationalSignificantNumber\",\n    value: function extractCallingCodeAndNationalSignificantNumber(state) {\n      if (this.extractCountryCallingCode(state)) {\n        // `this.extractCallingCode()` is currently called when the number\n        // couldn't be formatted during the standard procedure.\n        // Normally, the national prefix would be re-extracted\n        // for an international number if such number couldn't be formatted,\n        // but since it's already not able to be formatted,\n        // there won't be yet another retry, so also extract national prefix here.\n        this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n          return state.update(stateUpdate);\n        });\n      }\n    }\n  }]);\n}();\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\nexport { AsYouTypeParser as default };\nfunction extractFormattedPhoneNumber(text) {\n  // Attempt to extract a possible number from the string passed in.\n  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);\n  if (startsAt < 0) {\n    return;\n  }\n  // Trim everything to the left of the phone number.\n  text = text.slice(startsAt);\n  // Trim the `+`.\n  var hasPlus;\n  if (text[0] === '+') {\n    hasPlus = true;\n    text = text.slice('+'.length);\n  }\n  // Trim everything to the right of the phone number.\n  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '');\n  // Re-add the previously trimmed `+`.\n  if (hasPlus) {\n    text = '+' + text;\n  }\n  return text;\n}\n\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\nfunction _extractFormattedDigitsAndPlus(text) {\n  // Extract a formatted phone number part from text.\n  var extractedNumber = extractFormattedPhoneNumber(text) || '';\n  // Trim a `+`.\n  if (extractedNumber[0] === '+') {\n    return [extractedNumber.slice('+'.length), true];\n  }\n  return [extractedNumber];\n}\n\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\nexport function extractFormattedDigitsAndPlus(text) {\n  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text),\n    _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2),\n    formattedDigits = _extractFormattedDigi4[0],\n    hasPlus = _extractFormattedDigi4[1];\n  // If the extracted phone number part\n  // can possibly be a part of some valid phone number\n  // then parse phone number characters from a formatted phone number.\n  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\n    formattedDigits = '';\n  }\n  return [formattedDigits, hasPlus];\n}\n//# sourceMappingURL=AsYouTypeParser.js.map","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport Metadata from './metadata.js';\nimport PhoneNumber from './PhoneNumber.js';\nimport AsYouTypeState from './AsYouTypeState.js';\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.js';\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser.js';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js';\nimport getCountryByNationalNumber from './helpers/getCountryByNationalNumber.js';\nimport isObject from './helpers/isObject.js';\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;\nvar AsYouType = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n   * @param {Object} metadata\r\n   */\n  function AsYouType(optionsOrDefaultCountry, metadata) {\n    _classCallCheck(this, AsYouType);\n    this.metadata = new Metadata(metadata);\n    var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry),\n      _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2),\n      defaultCountry = _this$getCountryAndCa2[0],\n      defaultCallingCode = _this$getCountryAndCa2[1];\n    // `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.\n    // For example, `this.defaultCountry` could be `\"AR\"` and `this.defaultCallingCode` could be `undefined`.\n    // So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.reset();\n  }\n  return _createClass(AsYouType, [{\n    key: \"getCountryAndCallingCode\",\n    value: function getCountryAndCallingCode(optionsOrDefaultCountry) {\n      // Set `defaultCountry` and `defaultCallingCode` options.\n      var defaultCountry;\n      var defaultCallingCode;\n      // Turns out `null` also has type \"object\". Weird.\n      if (optionsOrDefaultCountry) {\n        if (isObject(optionsOrDefaultCountry)) {\n          defaultCountry = optionsOrDefaultCountry.defaultCountry;\n          defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;\n        } else {\n          defaultCountry = optionsOrDefaultCountry;\n        }\n      }\n      if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\n        defaultCountry = undefined;\n      }\n      if (defaultCallingCode) {\n        /* istanbul ignore if */\n        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n          if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n            defaultCountry = '001';\n          }\n        }\n      }\n      return [defaultCountry, defaultCallingCode];\n    }\n\n    /**\r\n     * Inputs \"next\" phone number characters.\r\n     * @param  {string} text\r\n     * @return {string} Formatted phone number characters that have been input so far.\r\n     */\n  }, {\n    key: \"input\",\n    value: function input(text) {\n      var _this$parser$input = this.parser.input(text, this.state),\n        digits = _this$parser$input.digits,\n        justLeadingPlus = _this$parser$input.justLeadingPlus;\n      if (justLeadingPlus) {\n        this.formattedOutput = '+';\n      } else if (digits) {\n        this.determineTheCountryIfNeeded();\n        // Match the available formats by the currently available leading digits.\n        if (this.state.nationalSignificantNumber) {\n          this.formatter.narrowDownMatchingFormats(this.state);\n        }\n        var formattedNationalNumber;\n        if (this.metadata.hasSelectedNumberingPlan()) {\n          formattedNationalNumber = this.formatter.format(digits, this.state);\n        }\n        if (formattedNationalNumber === undefined) {\n          // See if another national (significant) number could be re-extracted.\n          if (this.parser.reExtractNationalSignificantNumber(this.state)) {\n            this.determineTheCountryIfNeeded();\n            // If it could, then re-try formatting the new national (significant) number.\n            var nationalDigits = this.state.getNationalDigits();\n            if (nationalDigits) {\n              formattedNationalNumber = this.formatter.format(nationalDigits, this.state);\n            }\n          }\n        }\n        this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();\n      }\n      return this.formattedOutput;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this = this;\n      this.state = new AsYouTypeState({\n        onCountryChange: function onCountryChange(country) {\n          // Before version `1.6.0`, the official `AsYouType` formatter API\n          // included a `.country` property on an `AsYouType` instance.\n          // Since that property (along with the others) have been moved to\n          // `this.state`, `this.country` property is emulated for compatibility\n          // with the old versions.\n          _this.country = country;\n        },\n        onCallingCodeChange: function onCallingCodeChange(callingCode, country) {\n          _this.metadata.selectNumberingPlan(country, callingCode);\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n          _this.parser.reset(_this.metadata.numberingPlan);\n        }\n      });\n      this.formatter = new AsYouTypeFormatter({\n        state: this.state,\n        metadata: this.metadata\n      });\n      this.parser = new AsYouTypeParser({\n        defaultCountry: this.defaultCountry,\n        defaultCallingCode: this.defaultCallingCode,\n        metadata: this.metadata,\n        state: this.state,\n        onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {\n          _this.determineTheCountryIfNeeded();\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n        }\n      });\n      this.state.reset({\n        country: this.defaultCountry,\n        callingCode: this.defaultCallingCode\n      });\n      this.formattedOutput = '';\n      return this;\n    }\n\n    /**\r\n     * Returns `true` if the phone number is being input in international format.\r\n     * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isInternational\",\n    value: function isInternational() {\n      return this.state.international;\n    }\n\n    /**\r\n     * Returns the \"calling code\" part of the phone number when it's being input\r\n     * in an international format.\r\n     * If no valid calling code has been entered so far, returns `undefined`.\r\n     * @return {string} [callingCode]\r\n     */\n  }, {\n    key: \"getCallingCode\",\n    value: function getCallingCode() {\n      // If the number is being input in national format and some \"default calling code\"\n      // has been passed to `AsYouType` constructor, then `this.state.callingCode`\n      // is equal to that \"default calling code\".\n      //\n      // If the number is being input in national format and no \"default calling code\"\n      // has been passed to `AsYouType` constructor, then returns `undefined`,\n      // even if a \"default country\" has been passed to `AsYouType` constructor.\n      //\n      if (this.isInternational()) {\n        return this.state.callingCode;\n      }\n    }\n\n    // A legacy alias.\n  }, {\n    key: \"getCountryCallingCode\",\n    value: function getCountryCallingCode() {\n      return this.getCallingCode();\n    }\n\n    /**\r\n     * Returns a two-letter country code of the phone number.\r\n     * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n     * Returns `undefined` if no phone number has been input yet.\r\n     * @return {string} [country]\r\n     */\n  }, {\n    key: \"getCountry\",\n    value: function getCountry() {\n      var digits = this.state.digits;\n      // Return `undefined` if no digits have been input yet.\n      if (digits) {\n        return this._getCountry();\n      }\n    }\n\n    /**\r\n     * Returns a two-letter country code of the phone number.\r\n     * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n     * @return {string} [country]\r\n     */\n  }, {\n    key: \"_getCountry\",\n    value: function _getCountry() {\n      var country = this.state.country;\n      /* istanbul ignore if */\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        // `AsYouType.getCountry()` returns `undefined`\n        // for \"non-geographic\" phone numbering plans.\n        if (country === '001') {\n          return;\n        }\n      }\n      return country;\n    }\n  }, {\n    key: \"determineTheCountryIfNeeded\",\n    value: function determineTheCountryIfNeeded() {\n      // Suppose a user enters a phone number in international format,\n      // and there're several countries corresponding to that country calling code,\n      // and a country has been derived from the number, and then\n      // a user enters one more digit and the number is no longer\n      // valid for the derived country, so the country should be re-derived\n      // on every new digit in those cases.\n      //\n      // If the phone number is being input in national format,\n      // then it could be a case when `defaultCountry` wasn't specified\n      // when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\n      // and that \"calling code\" could correspond to a \"non-geographic entity\",\n      // or there could be several countries corresponding to that country calling code.\n      // In those cases, `this.country` is `undefined` and should be derived\n      // from the number. Again, if country calling code is ambiguous, then\n      // `this.country` should be re-derived with each new digit.\n      //\n      if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\n        this.determineTheCountry();\n      }\n    }\n\n    // Prepends `+CountryCode ` in case of an international phone number\n  }, {\n    key: \"getFullNumber\",\n    value: function getFullNumber(formattedNationalNumber) {\n      var _this2 = this;\n      if (this.isInternational()) {\n        var prefix = function prefix(text) {\n          return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {\n            spacing: text ? true : false\n          }) + text;\n        };\n        var callingCode = this.state.callingCode;\n        if (!callingCode) {\n          return prefix(\"\".concat(this.state.getDigitsWithoutInternationalPrefix()));\n        }\n        if (!formattedNationalNumber) {\n          return prefix(callingCode);\n        }\n        return prefix(\"\".concat(callingCode, \" \").concat(formattedNationalNumber));\n      }\n      return formattedNationalNumber;\n    }\n  }, {\n    key: \"getNonFormattedNationalNumberWithPrefix\",\n    value: function getNonFormattedNationalNumberWithPrefix() {\n      var _this$state = this.state,\n        nationalSignificantNumber = _this$state.nationalSignificantNumber,\n        prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _this$state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix,\n        nationalPrefix = _this$state.nationalPrefix;\n      var number = nationalSignificantNumber;\n      var prefix = prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix || nationalPrefix;\n      if (prefix) {\n        number = prefix + number;\n      }\n      return number;\n    }\n  }, {\n    key: \"getNonFormattedNumber\",\n    value: function getNonFormattedNumber() {\n      var nationalSignificantNumberIsModified = this.state.nationalSignificantNumberIsModified;\n      return this.getFullNumber(nationalSignificantNumberIsModified ? this.state.getNationalDigits() : this.getNonFormattedNationalNumberWithPrefix());\n    }\n  }, {\n    key: \"getNonFormattedTemplate\",\n    value: function getNonFormattedTemplate() {\n      var number = this.getNonFormattedNumber();\n      if (number) {\n        return number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER);\n      }\n    }\n  }, {\n    key: \"isCountryCallingCodeAmbiguous\",\n    value: function isCountryCallingCodeAmbiguous() {\n      var callingCode = this.state.callingCode;\n      var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);\n      return countryCodes && countryCodes.length > 1;\n    }\n\n    // Determines the exact country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n  }, {\n    key: \"determineTheCountry\",\n    value: function determineTheCountry() {\n      this.state.setCountry(getCountryByCallingCode(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {\n        nationalNumber: this.state.nationalSignificantNumber,\n        metadata: this.metadata\n      }));\n    }\n\n    /**\r\n     * Returns a E.164 phone number value for the user's input.\r\n     *\r\n     * For example, for country `\"US\"` and input `\"(222) 333-4444\"`\r\n     * it will return `\"+12223334444\"`.\r\n     *\r\n     * For international phone number input, it will also auto-correct\r\n     * some minor errors such as using a national prefix when writing\r\n     * an international phone number. For example, if the user inputs\r\n     * `\"+44 0 7400 000000\"` then it will return an auto-corrected\r\n     * `\"+447400000000\"` phone number value.\r\n     *\r\n     * Will return `undefined` if no digits have been input,\r\n     * or when inputting a phone number in national format and no\r\n     * default country or default \"country calling code\" have been set.\r\n     *\r\n     * @return {string} [value]\r\n     */\n  }, {\n    key: \"getNumberValue\",\n    value: function getNumberValue() {\n      var _this$state2 = this.state,\n        digits = _this$state2.digits,\n        callingCode = _this$state2.callingCode,\n        country = _this$state2.country,\n        nationalSignificantNumber = _this$state2.nationalSignificantNumber;\n\n      // Will return `undefined` if no digits have been input.\n      if (!digits) {\n        return;\n      }\n      if (this.isInternational()) {\n        if (callingCode) {\n          return '+' + callingCode + nationalSignificantNumber;\n        } else {\n          return '+' + digits;\n        }\n      } else {\n        if (country || callingCode) {\n          var callingCode_ = country ? this.metadata.countryCallingCode() : callingCode;\n          return '+' + callingCode_ + nationalSignificantNumber;\n        }\n      }\n    }\n\n    /**\r\n     * Returns an instance of `PhoneNumber` class.\r\n     * Will return `undefined` if no national (significant) number\r\n     * digits have been entered so far, or if no `defaultCountry` has been\r\n     * set and the user enters a phone number not in international format.\r\n     */\n  }, {\n    key: \"getNumber\",\n    value: function getNumber() {\n      var _this$state3 = this.state,\n        nationalSignificantNumber = _this$state3.nationalSignificantNumber,\n        carrierCode = _this$state3.carrierCode,\n        callingCode = _this$state3.callingCode;\n\n      // `this._getCountry()` is basically same as `this.state.country`\n      // with the only change that it return `undefined` in case of a\n      // \"non-geographic\" numbering plan instead of `\"001\"` \"internal use\" value.\n      var country = this._getCountry();\n      if (!nationalSignificantNumber) {\n        return;\n      }\n\n      // `state.country` and `state.callingCode` aren't required to be in sync.\n      // For example, `country` could be `\"AR\"` and `callingCode` could be `undefined`.\n      // So `country` and `callingCode` are totally independent.\n\n      if (!country && !callingCode) {\n        return;\n      }\n\n      // By default, if `defaultCountry` parameter was passed when\n      // creating `AsYouType` instance, `state.country` is gonna be\n      // that `defaultCountry`, which doesn't entirely conform with\n      // `parsePhoneNumber()`'s behavior where it attempts to determine\n      // the country more precisely in cases when multiple countries\n      // could correspond to the same `countryCallingCode`.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969\n      //\n      // Because `AsYouType.getNumber()` method is supposed to be a 1:1\n      // equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,\n      // then it should also behave accordingly in cases of `country` ambiguity.\n      // That's how users of this library would expect it to behave anyway.\n      //\n      if (country) {\n        if (country === this.defaultCountry) {\n          // `state.country` and `state.callingCode` aren't required to be in sync.\n          // For example, `state.country` could be `\"AR\"` and `state.callingCode` could be `undefined`.\n          // So `state.country` and `state.callingCode` are totally independent.\n          var metadata = new Metadata(this.metadata.metadata);\n          metadata.selectNumberingPlan(country);\n          var _callingCode = metadata.numberingPlan.callingCode();\n          var ambiguousCountries = this.metadata.getCountryCodesForCallingCode(_callingCode);\n          if (ambiguousCountries.length > 1) {\n            var exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {\n              countries: ambiguousCountries,\n              metadata: this.metadata.metadata\n            });\n            if (exactCountry) {\n              country = exactCountry;\n            }\n          }\n        }\n      }\n      var phoneNumber = new PhoneNumber(country || callingCode, nationalSignificantNumber, this.metadata.metadata);\n      if (carrierCode) {\n        phoneNumber.carrierCode = carrierCode;\n      }\n      // Phone number extensions are not supported by \"As You Type\" formatter.\n      return phoneNumber;\n    }\n\n    /**\r\n     * Returns `true` if the phone number is \"possible\".\r\n     * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isPossible\",\n    value: function isPossible() {\n      var phoneNumber = this.getNumber();\n      if (!phoneNumber) {\n        return false;\n      }\n      return phoneNumber.isPossible();\n    }\n\n    /**\r\n     * Returns `true` if the phone number is \"valid\".\r\n     * Is just a shortcut for `PhoneNumber.isValid()`.\r\n     * @return {boolean}\r\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var phoneNumber = this.getNumber();\n      if (!phoneNumber) {\n        return false;\n      }\n      return phoneNumber.isValid();\n    }\n\n    /**\r\n     * @deprecated\r\n     * This method is used in `react-phone-number-input/source/input-control.js`\r\n     * in versions before `3.0.16`.\r\n     */\n  }, {\n    key: \"getNationalNumber\",\n    value: function getNationalNumber() {\n      return this.state.nationalSignificantNumber;\n    }\n\n    /**\r\n     * Returns the phone number characters entered by the user.\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getChars\",\n    value: function getChars() {\n      return (this.state.international ? '+' : '') + this.state.digits;\n    }\n\n    /**\r\n     * Returns the template for the formatted phone number.\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate() {\n      return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || '';\n    }\n  }]);\n}();\nexport { AsYouType as default };\n//# sourceMappingURL=AsYouType.js.map","// Importing from a \".js\" file is a workaround for Node.js \"ES Modules\"\r\n// importing system which is even uncapable of importing \"*.json\" files.\r\nimport metadata from '../../metadata.mobile.json.js'\r\n\r\nimport { AsYouType as _AsYouType } from '../../core/index.js'\r\n\r\nexport function AsYouType(country) {\r\n\treturn _AsYouType.call(this, country, metadata)\r\n}\r\n\r\nAsYouType.prototype = Object.create(_AsYouType.prototype, {})\r\nAsYouType.prototype.constructor = AsYouType","import PhoneNumber from './PhoneNumber.js';\nexport default function getExampleNumber(country, examples, metadata) {\n  if (examples[country]) {\n    return new PhoneNumber(country, examples[country], metadata);\n  }\n}\n//# sourceMappingURL=getExampleNumber.js.map","import withMetadataArgument from './withMetadataArgument.js'\r\nimport { getExampleNumber as _getExampleNumber } from '../../core/index.js'\r\n\r\nexport function getExampleNumber() {\r\n\treturn withMetadataArgument(_getExampleNumber, arguments)\r\n}"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","_defineProperties","e","r","t","length","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","i","toPrimitive","call","TypeError","String","Number","_toPrimitive","AsYouTypeState","_ref","onCountryChange","onCallingCodeChange","a","n","_classCallCheck","this","value","_ref2","country","callingCode","international","missingPlus","IDDPrefix","undefined","digits","resetNationalSignificantNumber","initCountryAndCallingCode","nationalSignificantNumber","getNationalDigits","nationalSignificantNumberIsModified","nationalPrefix","carrierCode","prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix","properties","_i","_Object$keys","keys","setCountry","setCallingCode","nextDigits","slice","_createForOfIteratorHelperLoose","next","bind","Array","isArray","_arrayLikeToArray","toString","name","from","test","_unsupportedIterableToArray","done","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","repeat","string","times","result","cutAndStripNonPairedParens","cutBeforeIndex","dangling_braces","push","pop","start","cleared_string","_dangling_braces","index","stripNonPairedParens","formatCompleteNumber","state","format","metadata","shouldTryNationalPrefixFormattingRule","getSeparatorAfterNationalPrefix","concat","pattern","formattedNumber","formatNationalNumber","useNationalPrefixFormattingRule","formatNationalNumberWithAndWithoutNationalPrefixFormattingRule","_ref3","formattedNationalNumber","formatNationalNumberUsingFormat","useInternationalFormat","withNationalPrefix","parseDigits","isValidFormattedNationalNumber","PatternParser","context","or","instructions","parsePattern","Error","_this$context$","branches","op","args","expandSingleElementArray","match","OPERATOR","operator","before","rightPart","startContext","getContext","endContext","oneOfSet","parseOneOfSet","ILLEGAL_CHARACTER_REGEXP","split","values","prevValue","charCodeAt","nextValue","fromCharCode","array","PatternMatcher","matchTree","parse","allowOverflow","arguments","_match","matchedChars","overflow","characters","tree","last","characterString","join","indexOf","partialMatch","restCharacters","JSON","stringify","_step","_iterator","_result","_step2","_iterator2","_char","LONGEST_DUMMY_PHONE_NUMBER","NATIONAL_PREFIX_SEPARATORS_PATTERN","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","NON_ALTERING_FORMAT_REG_EXP","AsYouTypeFormatter","resetFormat","chosenFormat","template","nationalNumberTemplate","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","numberingPlan","isNANP","matchingFormats","formats","narrowDownMatchingFormats","_this","checkNumberLength","_format","formattedCompleteNumber","setNationalNumberTemplate","replace","lastIndexOf","formatNationalNumberWithNextDigits","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","_this2","leadingDigits","leadingDigitsPatternIndex","filter","formatSuits","formatMatches","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","error","console","internationalFormat","_this3","_loop","getFormatFormat","createTemplateForFormat","_","getTemplateForFormat","nationalPrefixFormattingRule","options","spacing","internationalPrefix","getInternationalPrefixBeforeCountryCallingCode","getDigitsWithoutInternationalPrefix","_ref4","strictPattern","nationalNumberDummyDigits","nationalPrefixIncludedInTemplate","numberFormat","numberFormatWithNationalPrefix","applyInternationalSeparatorStyle","position","digit","search","populateTemplateWithDigits","_ref5","_slicedToArray","_arrayWithHoles","l","u","f","_iterableToArrayLimit","_nonIterableRest","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","VALID_FORMATTED_PHONE_NUMBER_PART","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","COMPLEX_NATIONAL_PREFIX","AsYouTypeParser","defaultCountry","defaultCallingCode","onNationalSignificantNumberChange","text","justLeadingPlus","_extractFormattedDigi","_extractFormattedDigi3","extractedNumber","hasPlus","startsAt","extractFormattedPhoneNumber","_extractFormattedDigitsAndPlus","_extractFormattedDigi4","formattedDigits","extractFormattedDigitsAndPlus","_extractFormattedDigi2","startInternationalNumber","inputDigits","hasReceivedThreeLeadingDigits","appendDigits","extractIddPrefix","isWaitingForCountryCallingCode","extractCountryCallingCode","appendNationalSignificantNumberDigits","hasExtractedNationalSignificantNumber","extractNationalSignificantNumber","stateUpdate","update","_extractCountryCallin","countryCallingCode","number","hasSelectedNumberingPlan","nationalPrefixForParsing","_nationalPrefixForParsing","couldPossiblyExtractAnotherNationalSignificantNumber","nationalDigits","setState","_extractNationalNumbe","extractNationalNumberFromPossiblyIncompleteNumber","nationalNumber","onExtractedNationalNumber","prevNationalSignificantNumber","_extractNationalNumbe2","nationalSignificantNumberIndex","prefixBeforeNationalNumber","extractAnotherNationalSignificantNumber","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","numberWithoutIDD","stripIddPrefix","newCallingCode","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","AsYouType","optionsOrDefaultCountry","_this$getCountryAndCa2","getCountryAndCallingCode","reset","isObject","hasCountry","_this$parser$input","parser","input","formattedOutput","determineTheCountryIfNeeded","formatter","reExtractNationalSignificantNumber","getFullNumber","getNonFormattedNumber","selectNumberingPlan","isInternational","getCallingCode","_getCountry","isCountryCallingCodeAmbiguous","determineTheCountry","prefix","_this$state","getNonFormattedNationalNumberWithPrefix","countryCodes","getCountryCodesForCallingCode","getCountryByCallingCode","_this$state2","_this$state3","_callingCode","ambiguousCountries","exactCountry","getCountryByNationalNumber","countries","phoneNumber","PhoneNumber","getNumber","isPossible","isValid","getTemplate","getNonFormattedTemplate","create","getExampleNumber","examples","withMetadataArgument"],"ignoreList":[],"sourceRoot":""}